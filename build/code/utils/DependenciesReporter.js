// Generated by CoffeeScript 1.6.3
var DependenciesReporter, Dependency, l, _, _B,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

_B = require('uberscore');

Dependency = require('./../fileResources/Dependency');

l = new _B.Logger('urequire/utils/DependencyReporter');

DependenciesReporter = (function() {
  var DT, dependencyTypesMessages;

  function DependenciesReporter() {
    this.reportData = {};
  }

  dependencyTypesMessages = {
    /* 'problematic' ones*/

    untrusted: {
      header: "\u001b[31m Untrusted dependencies (i.e non literal String) found:",
      footer: "They are left AS-IS, BUT are added to the dependency array.\nIf evaluated name of the `require( utrusted + 'string' )` isnt in dependency array [..],\nyour app WILL HALT and WILL NOT WORK on the web/AMD side (but should be OK on node).\u001b[0m"
    }
  };

  /* simply interesting :-)*/


  DT = Dependency.TYPES;

  _B.okv(dependencyTypesMessages, DT.global, {
    header: "Global-looking dependencies (those without fileRelative (eg `./`) & not present in bundle's root):",
    footer: "Note: When executing on plain nodejs, globals are `require`d as is.\n      When executing on Web/AMD or uRequire/UMD they use `rjs.baseUrl`/`rjs.paths`, if present."
  }, DT.notFoundInBundle, {
    header: "\u001b[31m Bundle-looking dependencies not found in bundle:",
    footer: "They are added as-is.\u001b[0m"
  }, DT.external, {
    header: "External dependencies (not checked in this version):",
    footer: "They are added as-is."
  }, DT.webRootMap, {
    header: "Web root dependencies '/' (not checked in this version):",
    footer: "They are added as-is."
  });

  DependenciesReporter.prototype.reportedDepTypes = _.keys(dependencyTypesMessages);

  DependenciesReporter.prototype.reportTemplate = function(texts, dependenciesFound) {
    var dependency, mf, moduleFiles;
    return "\n" + texts.header + "\n  " + ((function() {
      var _results;
      _results = [];
      for (dependency in dependenciesFound) {
        moduleFiles = dependenciesFound[dependency];
        _results.push("'" + dependency + "' dependency appears in modules: [    " + ((function() {
          var _i, _len, _results1;
          _results1 = [];
          for (_i = 0, _len = moduleFiles.length; _i < _len; _i++) {
            mf = moduleFiles[_i];
            _results1.push("\n         '" + mf + "'");
          }
          return _results1;
        })()) + "\n  ]\n");
      }
      return _results;
    })()) + texts.footer + "\n";
  };

  DependenciesReporter.prototype.addReportData = function(resolvedDeps, modyle) {
    var depType, foundModules, resDep, resDeps, _base, _base1, _i, _len, _ref;
    for (depType in resolvedDeps) {
      resDeps = resolvedDeps[depType];
      if (!(!_.isEmpty(resDeps))) {
        continue;
      }
      (_base = this.reportData)[depType] || (_base[depType] = {});
      _ref = _B.arrayize(resDeps);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        resDep = _ref[_i];
        foundModules = ((_base1 = this.reportData[depType])[resDep] || (_base1[resDep] = []));
        if (__indexOf.call(foundModules, modyle) < 0) {
          foundModules.push(modyle);
        }
      }
    }
    return null;
  };

  DependenciesReporter.prototype.getReport = function(interestingDepTypes) {
    var depType, depTypesMsgs, report;
    if (interestingDepTypes == null) {
      interestingDepTypes = this.reportedDepTypes;
    }
    l.debug(95, 'Getting report only for types :', interestingDepTypes);
    report = "";
    for (depType in dependencyTypesMessages) {
      depTypesMsgs = dependencyTypesMessages[depType];
      if (__indexOf.call(interestingDepTypes, depType) >= 0) {
        if (this.reportData[depType]) {
          report += this.reportTemplate(depTypesMsgs, this.reportData[depType]);
        }
      }
    }
    return report;
  };

  return DependenciesReporter;

})();

module.exports = DependenciesReporter;
