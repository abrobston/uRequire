// Generated by CoffeeScript 1.6.3
var Dependency, l, pathRelative, upath, _, _B,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

_.mixin((require('underscore.string')).exports());

_B = require('uberscore');

l = new _B.Logger('urequire/fileResources/Dependency');

upath = require('./../paths/upath');

pathRelative = require('./../paths/pathRelative');

Dependency = (function() {
  /*
    @param {String} depString The original dependency, as passed i.e 'uberscore' or '../mylibs/dep'
  
    @param {Module} module The module that has this dependency (optional).
        Used to calculate relative paths via its `.path` property.
        Can be a {} optionally containing a:
         - .path, as String, i.e the bundleRelative filename eg 'somePath/ModuleName'
         - .bundle or any {} with {dstFilenames: Array<String>}
          The dstFilenames (bundleRelative) in the bundle are used to
          calculate whether './../myDep' isFound, which in turn is used by isGlobal and others etc.
  */

  var untrusted;

  function Dependency(depString, module, untrusted) {
    this.depString = depString;
    this.module = module;
    this.untrusted = untrusted;
  }

  Dependency.systemDeps = ['require', 'exports', 'module'];

  Dependency.TYPES = {
    notFoundInBundle: 'notFoundInBundle',
    global: 'global',
    external: 'external',
    webRootMap: 'webRootMap',
    bundle: 'bundle',
    system: 'system',
    untrusted: 'untrusted'
  };

  untrusted = function(str) {
    str = new String(str + '');
    str.untrusted = true;
    str.inspect = function() {
      return "'" + this + "' (untrusted Dependency)";
    };
    return str;
  };

  Object.defineProperties(Dependency.prototype, {
    depString: {
      get: function() {
        if (this.untrusted) {
          return untrusted(this._depString);
        } else {
          return this._depString;
        }
      },
      set: function(depString) {
        var dp, indexOfSep;
        if (depString == null) {
          depString = '';
        }
        this._depString = depString;
        dp = depString.replace(/\\/g, '/');
        indexOfSep = dp.indexOf('!');
        if (indexOfSep > 0) {
          this.pluginName = dp.slice(0, +(indexOfSep - 1) + 1 || 9e9);
        }
        this.resourceName = indexOfSep >= 0 ? dp.slice(indexOfSep + 1, +(this.depString.length - 1) + 1 || 9e9) : dp;
        if (upath.extname(this.resourceName)) {
          this.extname = upath.extname(this.resourceName);
          return this.resourceName = upath.trimExt(this.resourceName);
        }
      }
    },
    type: {
      get: function() {
        if (this.untrusted) {
          return Dependency.TYPES.untrusted;
        } else {
          if (this.isSystem) {
            return Dependency.TYPES.system;
          } else {
            if (this.isGlobal) {
              return Dependency.TYPES.global;
            } else {
              if (this.isExternal) {
                return Dependency.TYPES.external;
              } else {
                if (this.isNotFoundInBundle) {
                  return Dependency.TYPES.notFoundInBundle;
                } else {
                  if (this.isWebRootMap) {
                    return Dependency.TYPES.webRootMap;
                  } else {
                    return Dependency.TYPES.bundle;
                  }
                }
              }
            }
          }
        }
      }
    },
    _bundleRelative: {
      get: function() {
        if (this.untrusted) {
          return this.depString;
        } else {
          if (this.isFileRelative && this.isBundleBoundary) {
            return upath.normalize("" + (upath.dirname(this.module.path)) + "/" + this.resourceName);
          } else {
            return upath.normalizeSafe(this.resourceName);
          }
        }
      }
    },
    _fileRelative: {
      get: function() {
        var _ref;
        if (this.untrusted) {
          return this._depString;
        } else {
          if (((_ref = this.module) != null ? _ref.path : void 0) && this.isFound) {
            return pathRelative("$/" + (upath.dirname(this.module.path)), "$/" + this._bundleRelative, {
              dot4Current: true
            });
          } else {
            return upath.normalizeSafe(this.resourceName);
          }
        }
      }
    },
    isBundleBoundary: {
      get: function() {
        var _ref;
        if (this.untrusted || this.isWebRootMap || (!((_ref = this.module) != null ? _ref.path : void 0))) {
          return false;
        } else {
          return !!pathRelative("$/" + this.module.path + "/../../" + this.resourceName, "$");
        }
      }
    },
    isFileRelative: {
      get: function() {
        return !this.untrusted && this.resourceName[0] === '.';
      }
    },
    isRelative: {
      get: function() {
        return !this.untrusted && this.resourceName.indexOf('/') >= 0 && !this.isWebRootMap;
      }
    },
    isWebRootMap: {
      get: function() {
        return !this.untrusted && this.resourceName[0] === '/';
      }
    },
    isGlobal: {
      get: function() {
        return !(this.untrusted || this.isWebRootMap || this.isRelative || this.isFound || this.isSystem);
      }
    },
    isSystem: {
      get: function() {
        var _ref;
        return _ref = this.depString, __indexOf.call(Dependency.systemDeps, _ref) >= 0;
      }
    },
    /* external-looking deps, like '../../../some/external/lib'*/

    isExternal: {
      get: function() {
        return !this.untrusted && !(this.isBundleBoundary || this.isWebRootMap);
      }
    },
    isNotFoundInBundle: {
      get: function() {
        return !this.untrusted && this.isBundleBoundary && !(this.isFound || this.isGlobal || this.isSystem);
      }
    },
    isUntrusted: {
      get: function() {
        return this.untrusted === true;
      }
    },
    isFound: {
      get: function() {
        var _ref, _ref1, _ref2;
        if (_.isArray((_ref = this.module) != null ? (_ref1 = _ref.bundle) != null ? _ref1.dstFilenames : void 0 : void 0)) {
          return _ref2 = upath.defaultExt(this._bundleRelative, '.js'), __indexOf.call(this.module.bundle.dstFilenames, _ref2) >= 0;
        }
      }
    }
  });

  Dependency.prototype.name = function(options) {
    if (options == null) {
      options = {};
    }
    if (this.untrusted) {
      return this.depString;
    } else {
      if (options.ext == null) {
        options.ext = this.isExternal || this.isNotFoundInBundle ? true : false;
      }
      if (options.plugin == null) {
        options.plugin = true;
      }
      if (options.relative == null) {
        options.relative = 'file';
      }
      if (options.quote == null) {
        options.quote = false;
      }
      return "" + (options.quote ? "'" : '') + (options.plugin && this.pluginName && (this.pluginName !== 'node') ? this.pluginName + '!' : '') + (options.relative === 'bundle' ? this._bundleRelative : this._fileRelative) + (options.ext === false || !this.extname ? '' : this.extname) + (options.quote ? "'" : '');
    }
  };

  Dependency.prototype.toString = function() {
    return this.depString;
  };

  Dependency.prototype.inspect = function() {
    if (this.untrusted) {
      return this.depString;
    } else {
      return "'" + this.depString + "' | bundleRelative = '" + (this.name({
        relative: 'bundle'
      })) + "'";
    }
  };

  /*
  Compare this Dependency instance with another, either Dependency or a string representation of another type.
  It caters for different representations of
    * bundleRelative / fileRelative
    * having `.js` extension or not
  
  @param dep {Dependency | String | .toString} The depedency to compare with this - returns true if
  */


  Dependency.prototype.isEqual = function(dep) {
    var isSameJSFile;
    if (!dep || this.untrusted) {
      return false;
    }
    isSameJSFile = function(a, b) {
      return upath.defaultExt(a, '.js') === upath.defaultExt(b, '.js');
    };
    if (!(dep instanceof Dependency)) {
      dep = new Dependency(dep, this.module);
    }
    return isSameJSFile(this.name({
      relative: 'bundle',
      ext: true
    }), dep.name({
      relative: 'bundle',
      ext: true
    }));
  };

  return Dependency;

})();

module.exports = Dependency;
