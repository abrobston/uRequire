// Generated by CoffeeScript 1.6.3
var Build, BundleFile, UError, fs, l, upath, wrench, _, _B;

_ = require('lodash');

fs = require('fs');

_B = require('uberscore');

l = new _B.Logger('urequire/fileResources/BundleFile');

Build = require('../process/Build');

wrench = require("wrench");

upath = require('../paths/upath');

UError = require('../utils/UError');

/*
  Represents any file in the bundle (that matched `bundle.filez`)
*/


BundleFile = (function() {
  /*
    @param bundle {Object} The Bundle where this BundleFile belongs
    @param filename {String} bundleRelative eg 'models/PersonModel.coffee'
  */

  function BundleFile(data) {
    _.extend(this, data);
    this.dstFilename = this.srcFilename;
  }

  BundleFile.prototype.refresh = function() {
    var statProps, stats;
    if (!fs.existsSync(this.srcFilepath)) {
      throw new UError("BundleFile missing '" + this.srcFilepath + "'");
    } else {
      stats = _.pick(fs.statSync(this.srcFilepath), statProps = ['mtime', 'size']);
      if (!_.isEqual(stats, this.fileStats)) {
        this.fileStats = stats;
        this.hasChanged = true;
      } else {
        this.hasChanged = false;
        if (l.deb(90)) {
          l.debug("No changes in " + statProps + " of file '" + this.dstFilename + "' ");
        }
      }
    }
    return this.hasChanged;
  };

  BundleFile.prototype.reset = function() {
    delete this.fileStats;
    return delete this.hasErrors;
  };

  Object.defineProperties(BundleFile.prototype, {
    extname: {
      get: function() {
        return upath.extname(this.srcFilename);
      }
    },
    srcFilepath: {
      get: function() {
        var _ref;
        return upath.join(((_ref = this.bundle) != null ? _ref.path : void 0) || '', this.srcFilename);
      }
    },
    srcRealpath: {
      get: function() {
        return "" + (process.cwd()) + "/" + this.srcFilepath;
      }
    },
    srcExists: {
      get: function() {
        return fs.existsSync(this.srcFilepath);
      }
    },
    dstFilepath: {
      get: function() {
        var _ref, _ref1;
        return upath.join(((_ref = this.bundle) != null ? (_ref1 = _ref.build) != null ? _ref1.dstPath : void 0 : void 0) || '', this.dstFilename);
      }
    },
    dstRealpath: {
      get: function() {
        return "" + (process.cwd()) + "/" + this.dstFilepath;
      }
    },
    dstExists: {
      get: function() {
        if (this.dstFilepath) {
          return fs.existsSync(this.dstFilepath);
        }
      }
    },
    sourceMapInfo: {
      get: function() {
        return {
          file: upath.basename(this.dstFilepath),
          sourceRoot: upath.dirname(upath.relative(upath.dirname(this.dstFilepath), this.srcFilepath)),
          sources: [upath.basename(this.srcFilepath)],
          sourceMappingURL: "/*\n//@ sourceMappingURL=" + (upath.basename(this.dstFilepath)) + ".map\n*/"
        };
      }
    }
  });

  BundleFile.prototype.copy = function(srcFilename, dstFilename) {
    var _ref, _ref1, _ref2;
    if (srcFilename == null) {
      srcFilename = this.srcFilename;
    }
    if (dstFilename == null) {
      dstFilename = this.srcFilename;
    }
    return BundleFile.copy(upath.join(((_ref = this.bundle) != null ? _ref.path : void 0) || '', srcFilename), upath.join(((_ref1 = this.bundle) != null ? (_ref2 = _ref1.build) != null ? _ref2.dstPath : void 0 : void 0) || '', dstFilename));
  };

  BundleFile.copy = function(srcFile, dstFile, overwrite) {
    var BUF_LENGTH, buff, bytesRead, compStats, err, fdr, fdw, pos, srcStats;
    if (overwrite == null) {
      overwrite = 'DUMMY';
    }
    if (!fs.existsSync(srcFile)) {
      throw new UError("copy: source file missing '" + srcFile + "'");
    } else {
      srcStats = _.pick(fs.statSync(srcFile), ['atime', 'mtime', 'size']);
      if (fs.existsSync(dstFile)) {
        compStats = ['mtime', 'size'];
        if (_.isEqual(_.pick(srcStats, compStats), _.pick(fs.statSync(dstFile), compStats))) {
          if (l.deb(80)) {
            l.debug("NOT copying same src & dst files: srcFile='" + srcFile + "', dstFile='" + dstFile + "'");
          }
          return false;
        }
      }
    }
    if (l.deb(40)) {
      l.debug("copy {src='" + srcFile + "', dst='" + dstFile + "'}");
    }
    try {
      BUF_LENGTH = 64 * 1024;
      buff = new Buffer(BUF_LENGTH);
      fdr = fs.openSync(srcFile, 'r');
      if (!(fs.existsSync(upath.dirname(dstFile)))) {
        l.verbose("Creating directory " + (upath.dirname(dstFile)));
        wrench.mkdirSyncRecursive(upath.dirname(dstFile));
      }
      fdw = fs.openSync(dstFile, 'w');
      bytesRead = 1;
      pos = 0;
      while (bytesRead > 0) {
        bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);
        fs.writeSync(fdw, buff, 0, bytesRead);
        pos += bytesRead;
      }
      fs.closeSync(fdr);
      fs.closeSync(fdw);
      fs.utimesSync(dstFile, srcStats.atime, srcStats.mtime);
      return true;
    } catch (_error) {
      err = _error;
      throw new UError("copy: Error copying from '" + srcFile + "' to '" + dstFile + "'", {
        nested: err
      });
    }
  };

  BundleFile.requireUncached = function(name) {
    var searchCache;
    searchCache = function(name, callback) {
      var mod, run;
      mod = require.resolve(name);
      if (mod && ((mod = require.cache[mod]) !== void 0)) {
        return (run = function(mod) {
          mod.children.forEach(function(child) {
            return run(child);
          });
          return callback(mod);
        })(mod);
      }
    };
    searchCache(name, function(mod) {
      return delete require.cache[mod.id];
    });
    return require(name);
  };

  BundleFile.prototype.requireUncached = function(name) {
    if (name == null) {
      name = this.srcRealpath;
    }
    return BundleFile.requireUncached(name);
  };

  BundleFile.prototype.inspect = function() {
    var inspectText;
    inspectText = " " + this.constructor.name + " : '" + this.srcFilename + "' ";
    if (this.hasChanged) {
      inspectText += '(hasChanged)';
    }
    if (this.hasErrors) {
      inspectText += '(hasErrors)';
    }
    return inspectText;
  };

  return BundleFile;

})();

module.exports = BundleFile;
